# Задача 3
**Ускорить запрос "anti-join", добиться времени выполнения < 10sec**
```sql
select day from t2 where t_id not in ( select t1.id from t1 );
```
## Решение
Для начала немного вводной информации:
- в начале каждого задания у нас нет индексов (даже если они остались после предыдущих решений, я их удаляю, чтобы начать с пустого листа),
- `max_parallel_workers_per_gather=0` как условие сохраняется всегда,
- настроенная во время моих попыток решить задачу 2 `work_mem = '64MB'` остаётся и здесь (я забыла вернуть предыдущее значение),

> Так как данное решение будет полноценно выложено уже 21 апреля, то есть с просроком в 1 день, я полностью осознаю, что оно может не учитываться при отборе на стажировку. Но мне просто понравилось решать эти задачи, так что я продолжу их выкладывать по мере выполнения.

Для начала посмотрим план выполнения запроса.
```sql
explain select day from t2 where t_id not in ( select t1.id from t1 );
--                                 QUERY PLAN
----------------------------------------------------------------------------
-- Seq Scan on t2  (cost=0.00..743656627159.09 rows=2499878 width=9)
--   Filter: (NOT (SubPlan 1))
--   SubPlan 1
--     ->  Materialize  (cost=0.00..272474.54 rows=10001036 width=4)
--           ->  Seq Scan on t1  (cost=0.00..183402.36 rows=10001036 width=4)
--(5 rows)
```
> Ради интереса, я запустила `explain analyze` этого запроса, чтобы узнать время его выполнения. Как вы можете понять, я принудительно завершила это процесс примерно через час, так как ноутбук начал немного нагреваться. Да и надо было двигаться дальше.

У нас используется последовательное сканирование, т.е. полный просмотр, таблицы t2 на соответствие условию. С учётом последующей материализации и последовательного сканирования таблицы t1, использование оператора `not in` - излишне дорогостоящая операция. 

Так как наши таблицы достаточно большие для эффективного использования `not in`, изменим запрос, используя `not exists`.

```sql
explain analyze select day from t2 where not exists ( select 1 from t1 where t1.id = t2.t_id );
--                                                        QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------
-- Hash Right Anti Join  (cost=168779.51..592173.71 rows=1 width=9) (actual time=10641.427..10641.430 rows=0 loops=1)
--   Hash Cond: (t1.id = t2.t_id)
--   ->  Seq Scan on t1  (cost=0.00..183379.01 rows=9998701 width=4) (actual time=0.017..1777.530 rows=10000000 loops=1)
--   ->  Hash  (cost=81869.56..81869.56 rows=4999756 width=13) (actual time=2196.434..2196.435 rows=5000000 loops=1)
--         Buckets: 4194304  Batches: 4  Memory Usage: 91371kB
--         ->  Seq Scan on t2  (cost=0.00..81869.56 rows=4999756 width=13) (actual time=0.028..947.990 rows=5000000 loops=1)
-- Planning Time: 0.921 ms
-- Execution Time: 10650.524 ms
--(8 rows)
```
Этот запрос уже выглядит гораздо лучше <s>(он хотя бы выполняется)</s>. Для его выполнения используется хэш-объединение таблиц с последовательным сканированием. В целом `not exists` более заточен на выполнение необходимой нам операции проверки существования строк, так как он не зависит от NULL-значений в подзапросе.

Так как время выполнения запроса немного перевалило за 10 секунд, попробуем добавить индексы на сравниваемые колонки.
```sql
create index t1_id on t1 (id); 
--CREATE INDEX
create index t2_t_id on t2 (t_id);
--CREATE INDEX
analyze t1; 
--ANALYZE
analyze t2;
--ANALYZE
explain analyze select day from t2 where not exists ( select 1 from t1 where t1.id = t2.t_id );
--                                                        QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------
-- Hash Right Anti Join  (cost=168784.27..592216.15 rows=1 width=9) (actual time=7388.296..7388.298 rows=0 loops=1)
--   Hash Cond: (t1.id = t2.t_id)
--   ->  Seq Scan on t1  (cost=0.00..183392.35 rows=10000035 width=4) (actual time=0.012..1052.718 rows=10000000 loops=1)
--   ->  Hash  (cost=81871.23..81871.23 rows=4999923 width=13) (actual time=1431.323..1431.325 rows=5000000 loops=1)
--         Buckets: 4194304  Batches: 4  Memory Usage: 91371kB
--         ->  Seq Scan on t2  (cost=0.00..81871.23 rows=4999923 width=13) (actual time=0.065..578.846 rows=5000000 loops=1)
-- Planning Time: 3.323 ms
-- Execution Time: 7396.392 ms
--(8 rows)
```
И план запроса абсолютно не изменился. Планировщик считает, что последовательное сканирование при объединении таблиц более эффективно, чем использование индексов.\
При этом время выполения запроса чудесным образом стало меньше 10 секунд.

> Если запустить обе версии запроса на наших данных, то получится, что мы перешли от запроса, который бесконечно выполняется, к запросу, который ничего не выдаёт.\
> ¯\\_(ツ)\_/¯
